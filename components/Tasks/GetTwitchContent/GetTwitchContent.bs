sub main()
    if m.top.contentRequested.contentType = "CLIP"
        content = CreateObject("roSGNode", "TwitchContentNode")
        content.setFields(m.top.contentRequested)
        content.url = Left(m.top.contentRequested.previewImageUrl, Len(m.top.contentRequested.previewImageUrl) - 20) + ".mp4"
        content.StreamUrls = [content.url]
        content.streamQualities = ["HD"]
        content.streamContentIds = ["Original"]
    else
        if m.top.contentRequested.contentType = "VOD"
            rsp = TwitchGraphQLRequest({
                query: `query VodPlayerWrapper_Query(
            $videoId: ID!
            $platform: String!
            $playerType: String!
            $skipPlayToken: Boolean!
            ) {
            ...VodPlayerWrapper_token
            }
            fragment VodPlayerWrapper_token on Query {
            video(id: $videoId) @skip(if: $skipPlayToken) {
                playbackAccessToken(params: {platform: $platform, playerType: $playerType}) {
                    signature
                   value
                }
                id
                __typename
            }
        }`
                variables: {
                    "videoId": m.top.contentRequested.contentId
                    "platform": "web_tv"
                    "playerType": "pulsar"
                    "skipPlayToken": false
                }
            })

        end if
        if m.top.contentRequested.contentType = "LIVE"
            rsp = TwitchGraphQLRequest({
                query: `query StreamPlayer_Query(
            $login: String!
            $playerType: String!
            $platform: String!
            $skipPlayToken: Boolean!
            ) {
            ...StreamPlayer_token
            }

            fragment StreamPlayer_token on Query {
            user(login: $login) {
                login
                stream @skip(if: $skipPlayToken) {
                    playbackAccessToken(params: {platform: $platform, playerType: $playerType}) {
                        signature
                        value
                    }
                    id
                    __typename
                }
                id
                __typename
            }
        }`
                variables: {
                    "login": m.top.contentRequested.streamerLogin
                    "platform": "web_tv"
                    "playerType": "roku"
                    "skipPlayToken": false
                }
            })
        end if

        ' Check user's latency preference
        latencyPreference = get_user_setting("preferred.latency", "low")
        lowLatencyEnabled = (latencyPreference = "low")

        if m.top.contentRequested.contentType = "VOD"
            usherUrl = "https://usher.ttvnw.net/vod/" + rsp.data.video.id + ".m3u8?playlist_include_framerate=true&allow_source=true&player_type=pulsar&player_backend=mediaplayer&reassignments_supported=true&nauth=" + rsp.data.video.playbackAccessToken.value.EncodeUri() + "&nauthsig=" + rsp.data.video.playbackAccessToken.signature
        else if m.top.contentRequested.contentType = "LIVE"
            ' Build base URL with appropriate latency parameters
            usherUrl = "https://usher.ttvnw.net/api/channel/hls/" + rsp.data.user.login + ".m3u8"
            usherUrl += "?allow_source=true"
            usherUrl += "&token=" + rsp.data.user.stream.playbackaccesstoken.value.EncodeUriComponent()
            usherUrl += "&sig=" + rsp.data.user.stream.playbackaccesstoken.signature.EncodeUriComponent()

            ' Add parameters based on latency preference
            if lowLatencyEnabled
                ' Request low latency streams specifically
                usherUrl += "&low_latency=true"
                usherUrl += "&playlist_include_framerate=true"
                usherUrl += "&supported_codecs=avc1"
                usherUrl += "&p=" + CreateObject("roDeviceInfo").GetRandomUUID()
                usherUrl += "&player_backend=mediaplayer"
                usherUrl += "&reassignments_supported=true"
                usherUrl += "&cdm=wv"
                usherUrl += "&player_version=1.0.0"
                usherUrl += "&fast_bread=true"
                usherUrl += "&allow_audio_only=false"
                usherUrl += "&allow_spectre=false"
                usherUrl += "&player_type=roku_tv"
                ' Force lower segment duration for reduced latency
                usherUrl += "&segment_preference=2"
            else
                ' Normal latency parameters
                usherUrl += "&playlist_include_framerate=true"
                usherUrl += "&player_backend=mediaplayer"
            end if
        end if

        req = HttpRequest({
            url: usherUrl
            headers: {
                "Accept": "*/*"
                "Origin": "https://android.tv.twitch.tv"
                "Referer": "https://android.tv.twitch.tv/"
                "User-Agent": "Mozilla/5.0 (SMART-TV; LINUX; Tizen 6.0) AppleWebKit/537.36 (KHTML, like Gecko) 85.0.4183.93/6.0 TV Safari/537.36"
                "Client-ID": "kimne78kx3ncx6brgo4mv6wki5h1ko"
            }
            method: "GET"
        })

        while true
            usher_rsp = req.send().getString()
            if usher_rsp <> invalid
                exit while
            end if
            sleep(10)
        end while

        list = usher_rsp.Split(chr(10))
        first_stream_link = ""
        last_stream_link = ""
        link = ""
        cnt = 0
        fps = invalid
        stream_objects = []

        for line = 0 to list.Count() - 1
            if list[line].InStr("#EXT-X-STREAM-INF:") = 0
                stream_info = list[line].Split(",")
                streamobject = {}
                for info = 0 to stream_info.Count() - 1
                    info_parsed = stream_info[info].Split("=")
                    if info_parsed.Count() >= 2
                        key = info_parsed[0].replace("#EXT-X-STREAM-INF:", "")
                        value = toString(info_parsed[1], true).replace(chr(34), "")
                        streamobject[key] = value
                    end if
                end for

                ' Get the URL from the next line
                if line + 1 < list.Count() and list[line + 1].InStr("#") <> 0
                    streamobject["URL"] = list[line + 1]
                    stream_objects.push(streamobject)
                end if
            end if
        end for

        stream_bitrates = []
        stream_urls = []
        stream_qualities = []
        stream_content_ids = []
        stream_sticky = []
        stream_formats = []
        streams = []
        metadata = []

        for each stream_item in stream_objects
            if stream_item["RESOLUTION"] <> invalid and stream_item["URL"] <> invalid
                res = stream_item["RESOLUTION"].split("x")[1]

                if stream_item["VIDEO"] = "chunked"
                    if stream_item["FRAME-RATE"] <> invalid
                        fps = stream_item["FRAME-RATE"].split(".")[0]
                    end if
                    value = res + "p"
                    if fps <> invalid
                        value = value + fps + " (Source)"
                    end if
                    if lowLatencyEnabled
                        value = value + " LL"
                    end if
                else
                    value = stream_item["VIDEO"]
                    if lowLatencyEnabled
                        value = value + " LL"
                    end if
                end if

                if m.global?.supportedgraphicsresolution <> invalid
                    if res.ToInt() > m.global.supportedgraphicsresolution
                        ? "Res Skip: "; res
                        continue for
                    end if
                end if

                if res.ToInt() >= 720
                    stream_qualities.push(true)
                    stream_quality = true
                else
                    stream_qualities.push(false)
                    stream_quality = false
                end if

                ' Use the stream URL as-is from the playlist
                streamUrl = stream_item["URL"]

                stream_bitrates.push(Int(Val(stream_item["BANDWIDTH"])) / 1000)
                stream_sticky.push(false)
                stream_content_ids.push(value)
                stream_urls.push(streamUrl)
                stream_formats.push("hls")

                stream = {
                    url: streamUrl
                    stickyredirects: false
                    quality: stream_quality
                    contentid: value
                    bitrate: Int(Val(stream_item["BANDWIDTH"])) / 1000
                }
                streams.push(stream)

                metadata.push({
                    QualityID: value
                    Streams: [stream]
                    StreamUrls: [streamUrl]
                    StreamStickyHttpRedirects: [false]
                    StreamQualities: [stream_quality]
                    StreamContentIds: [value]
                    StreamBitrates: [Int(Val(stream_item["BANDWIDTH"])) / 1000]
                })
            end if
        end for

        ' Sort streams appropriately
        if streams.Count() > 0
            ' For low latency, prefer lower bitrate streams to reduce latency
            if lowLatencyEnabled and m.top.contentRequested.contentType = "LIVE"
                ' Sort by bitrate (lowest first) for low latency
                for i = 0 to streams.Count() - 2
                    for j = i + 1 to streams.Count() - 1
                        if streams[i].bitrate > streams[j].bitrate
                            ' Swap all arrays
                            temp = streams[i]
                            streams[i] = streams[j]
                            streams[j] = temp

                            temp_meta = metadata[i]
                            metadata[i] = metadata[j]
                            metadata[j] = temp_meta

                            temp_val = stream_bitrates[i]
                            stream_bitrates[i] = stream_bitrates[j]
                            stream_bitrates[j] = temp_val

                            temp_val = stream_urls[i]
                            stream_urls[i] = stream_urls[j]
                            stream_urls[j] = temp_val

                            temp_val = stream_qualities[i]
                            stream_qualities[i] = stream_qualities[j]
                            stream_qualities[j] = temp_val

                            temp_val = stream_content_ids[i]
                            stream_content_ids[i] = stream_content_ids[j]
                            stream_content_ids[j] = temp_val

                            temp_val = stream_sticky[i]
                            stream_sticky[i] = stream_sticky[j]
                            stream_sticky[j] = temp_val
                        end if
                    end for
                end for
            else
                ' Sort by bitrate (highest first) for normal quality preference
                for i = 0 to streams.Count() - 2
                    for j = i + 1 to streams.Count() - 1
                        if streams[i].bitrate < streams[j].bitrate
                            ' Swap all arrays
                            temp = streams[i]
                            streams[i] = streams[j]
                            streams[j] = temp

                            temp_meta = metadata[i]
                            metadata[i] = metadata[j]
                            metadata[j] = temp_meta

                            temp_val = stream_bitrates[i]
                            stream_bitrates[i] = stream_bitrates[j]
                            stream_bitrates[j] = temp_val

                            temp_val = stream_urls[i]
                            stream_urls[i] = stream_urls[j]
                            stream_urls[j] = temp_val

                            temp_val = stream_qualities[i]
                            stream_qualities[i] = stream_qualities[j]
                            stream_qualities[j] = temp_val

                            temp_val = stream_content_ids[i]
                            stream_content_ids[i] = stream_content_ids[j]
                            stream_content_ids[j] = temp_val

                            temp_val = stream_sticky[i]
                            stream_sticky[i] = stream_sticky[j]
                            stream_sticky[j] = temp_val
                        end if
                    end for
                end for
            end if
        end if

        ' For low latency mode, create a fixed quality selection instead of adaptive
        if lowLatencyEnabled and m.top.contentRequested.contentType = "LIVE" and streams.Count() > 0
            ' Use only the lowest bitrate stream for minimal latency
            selectedStream = streams[0]
            metadata.unshift({
                QualityID: "Low Latency"
                StreamBitrates: [selectedStream.bitrate]
                streams: [selectedStream]
                StreamUrls: [selectedStream.url]
                StreamQualities: [selectedStream.quality]
                StreamContentIDs: [selectedStream.contentid]
                StreamStickyHttpRedirects: [false]
            })
        else
            ' Normal automatic quality selection
            metadata.unshift({
                QualityID: "Automatic"
                StreamBitrates: stream_bitrates
                streams: streams
                StreamUrls: stream_urls
                StreamQualities: stream_qualities
                StreamContentIDs: stream_content_ids
                StreamStickyHttpRedirects: stream_sticky
            })
        end if

        responseObj = []
        content = CreateObject("roSGNode", "TwitchContentNode")
        content.setFields(m.top.contentRequested)

        userQualityPreference = get_user_setting("playback.video.quality", "auto")

        if userQualityPreference = "highest" and metadata.Count() > 1
            content.setFields(metadata[1])
        else if userQualityPreference = "lowest" and metadata.Count() > 0
            ' Select the lowest quality stream for minimal latency
            lowestQualityIndex = metadata.Count() - 1
            content.setFields(metadata[lowestQualityIndex])
        else
            ' Use automatic/low latency selection (index 0)
            content.setFields(metadata[0])
        end if

        m.top.metadata = metadata
    end if
    m.top.response = content
end sub